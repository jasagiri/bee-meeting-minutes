# WG Meeting - Network - 2020-03-03

## Participants

- Alexander Schmidt
- Samuel Rufinatscha

## Discussion topics

### Current status

#### What is implemented?
<!--
- All relevant abstractions are here;
- Relatively intuitive; API is straight-forward (CommandSender; EventSub; Shutdown) and fullfills the needs;
- Channel based architecture; actors used to avoid locks;
- Fully based on async-std (e.g. not mixed with tokio, ...);
- All relevant events are implemented (events can be added on desire if needed);
- Sending/receiving is working; adding of peers is working;
- Interaction (API) with networking-layer working;
- Graceful shutdown is implemented;
-->
- 関連するすべての抽象化はここにあります。
- 比較的直観的；APIは直観的（CommonSender; EventSub; Shutdown）で、ニーズを十分に満たしています。
- チャネルベースのアーキテクチャ；アクターはロックを避けるために使用されます。
- 完全にasync-stdに基づいている（例えばtokioなどと混ざらない）。
- すべての関連イベントが実装されている（必要に応じてイベントを追加することができる）。
- 送受信は動作しています；ピアの追加は動作しています。
- ネットワーク層とのインタラクション（API）は動作しています。
- 優雅なシャットダウンが実装されています。

#### What is missing?
<!--
- Removal of 'is_broken', 'is_not_broken' TcpConnection API;
- Proper error handling;
- Optimizations (e.g. split tcp stream, less cloning);
- Detection of when a peer stalled (not that relevant, can be added later);
- Unit and integration testing;
- Integration in bee-p;
-->
- `is_broken`および`is_not_broken`TcpConnection APIの削除
- 適切なエラー処理
- 最適化（例：tcpストリームの分割、クローニングの削減）
- ピアがストールしたときの検出（あまり関係ありません。後から追加できます）。
- ユニットテストと総合テスト
- bee-pでの統合

### Current roadblocks
<!--
- handling duplicate connections;
-->
- 重複接続の処理

### Recognizing duplicate connections
<!--
- Duplicate connections might be detected in the protocol layer and are not necessarly topic of the networking layer;
- Has to be compatible with the current mainet;
- Checking in detail was Hornet and IRI is doing;
-->
- 重複接続はプロトコル層で検出される可能性があり、ネットワーク層の渡井になる必要はありません。
- 現在のメインネットとの互換性が必要。
- 詳細をチェックするとHornetとIRIがやっていることになっていた。

### Removement of the `is_broken` API
<!--
- Currently before reading/writing messages it will be checked if connections are still alive;
- Agreed that this doesn't necessarly works in every case and therefore it makes sense to handle errors directly on reading/writing;
-->
- 現在のところ、メッセージを読み書きする前に、接続がまだ生きているかどうかチェックします。
- これは駆らなず氏もすべてのケースで動作するわけではないので、読み書きの際に直接エラー処理するほうが理にかなっていることに同意します。

### Splitting read/write in separate actors
<!--
- The reading and writing of messages will be split into their separate actors;
- Contributes to concurrency;
- Will be implemented;
-->
- メッセージの読み書きは、それらの別々のアクターに分割されます。
- 並行性に貢献します。
- 実装される予定です。

### The use of independent connections for read and write
<!--
- Advantages:
    - will be more performant as reads and writes can happen concurrently;
- Disadvantages:
    - adds complexity; keeping track of related connections might introduce difficulties;
    - the termination of sessions needs to be adjusted;
- Might be considered for future optimizations;
-->
- 長所：
    - 読み取りと書き込みを同時に行うことができるので、よりパフォーマンスが高くなります。
- 短所：
    - 関連する接続を追跡することが困難になるかもしれません。
    - セッションの終了を調整する必要があります。
    - 将来の最適化のために検討されるかもしれません。

### Update underlying connections on failure;
<!--
- Sessions to certain peers could be keept alive, even if the underlying connection fails;
- Adds however some complexity; connections need to be replaced when they fail;
- Needs some more brainstorming if advantages outweight disadvantages;
-->
- 特定のピアへのセッションは、基礎となる接続に障害が発生しても生きていることができます。
- しかし、いくつかの複雑さを追加します；彼らが失敗したときに接続を置き換える必要があります。
- メリットがデメリットを上回る場合は、より多くのブレーンストーミングが必要です。

### When to shutdown read/writer halves?
<!--
- Shutdown should be done first on write-tasks and then read-tasks;
- The buffer of read_tasks should read-in first before terminating the connection;
-->
- シャットダウンは書き込みタスクで最初に行い、次に読み込みタスクで行うべきです。
- read-inのバッファは、接続を終了する前に最初に読み込まなければなりません。

### What should PeerId be derived from?
<!--
- We need to differ between IOTA Node IDs (introduced in upper layers), local-generated and assigned UUIDs, or sockets;
- A socket represents/identifies already the communication link;
- Information of the socket (e.g. host, port, protocol) could be very well suited to use to identify the endpoint;
- For now ip:port therefore fullfills the requirments;
-->
- IOTAノードID（上位層で導入される）、ローカルで生成され、割り当てられたUUID、ソケットを区別する必要があります。
- ソケットはすでにい通信リンクを表しています。
- ソケットの情報（ホスト、ポート、プロトコルなど）は、エンドポイントを識別するのに非常に適しています。
- 今のことろip:portで十分です。