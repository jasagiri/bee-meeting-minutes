# Working Group Meeting - Tangle - 2020-03-12

## Participants

- Joshua Barreto
- Tsvi Sabo
- Alexander Schmidt
- Samuel Rufinatscha

## Discussion topics
<!--
- refactor Tangle as a singleton, required to make it work at all
- putting the Tangle datastructure inside of an RwLock
- needs integration with the storage crate
- we have a single-threaded version
- need traversal of future and past cone
- currently using hashmap rather than graph library for simplicity reasons
- Async: What needs to access it? When? What kind of work? Common access patterns?
- Solidification: Separate "mid-solidification" state, propagated down to tangle main
- Solidification work: performed upon mutable access to the tangle. Pauseable?
-->
- Tangleをシングルトンとしてリファクタリングします。
- Tangleデータ構造をRwLock内に置きます。
- storageクレートとの統合が必要です。
- シングルスレッド版
- 必要なのは、未来と過去の円錐の横断です。
- 単純化のために、現在はグラフライブラリではなくハッシュマップを使用しています。
- 非同期：何がアクセスる必要があるか？いつか？どのような作業か？共通のアクセスパターンは？
- 凝固：分離した「中間固化」状態、tangleメインに伝播します。
- 固化作業：tangleへの変異可能なアクセス時に実行される。一時停止可能？

### Next steps
<!--
- define types; getting basic structure ready
- components can be added on top
- distinct things to do:
    - solidification worker / data
    - vertex API
    - tangle structure & utility methods
    - storage worker (later)
-->
- 型の定義：基本的な構造の準備
- コンポーネントを追加することができます。
- ハッキリとしたこと
    - 凝固作業員/データ
    - 頂点API
    - tangle構造とユーティリティメソッド
    - ストレージ係

## Links

- https://docs.rs/async-std/1.5.0/async_std/sync/struct.RwLock.html
- https://github.com/xacrimon/dashmap
- https://github.com/jonhoo/rust-evmap

### Current status
<!--
    * interop with storage crate: broken atm, need changes to bundle
-->
    * storageクレートとのインターホップ：壊れたatm、バンドルの変更が必要です。

### Current roadblocks
<!--
    * busy with other crates
-->
    * 他のクレートで忙しい。

### Tasks
<!--
    * split tasks as soon as types are there
-->
    * 型があるとすぐにタスクを分割します。

```rust=
struct Tangle {
	main: TangleMain,
	solidification: SolidificationState,
}

impl Tangle {
	// Access the tangle through this method, requires doing work
	fn do_for(&self, f: impl FnOnce(&TangleMain)) {
		f(&self.main);
		self.soldification.do_work(&self.main, N);
	}
}

struct TangleMain {
	map: EvMap<Hash, Vertex>,
}

struct SolidificationState {
	verts: HashMap<Hash, Vertex>,
	verts_rev: HashMap<Hash, Vertex>,
}

impl SolidificationState {
	// Performs partial solidification
	fn do_work(main: &TangleMain, iters: usize) { .. }
}
```

```rust=
struct VertexMeta {
    hash: Hash,
    trunk: Hash,
    branch: Hash,
}

struct Vertex {
    tangle: &'static Tangle,
    meta: VertexMeta,
}

impl Vertex {
    async fn get_trunk(&self) -> Vertex {
        let meta = self.tangle.get_meta_of(self.meta.trunk).await;
        Vertex {
            tangle: self.tangle,
            meta,
        }
    }
}


let v: Vertex = Vertex::from_hash(hash);

let v1: Vertex = v.get_trunk().await;
```




```rust=
struct Vertex {
    ...
    last_access: AtomicU64,
}

struct Tangle {
    map: EvMap<Hash, Vertex>,
}

impl Tangle {
    fn get(&self, hash: Hash) -> &Vertex {
        let v = self.map.get(&hash);
        v.last_access.store(ctime, Ordering::Relaxed);
        v
    }
}
```